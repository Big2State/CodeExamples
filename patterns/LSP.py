# Демонстрация принципа подстановки Барбары Лисков (LSP) на примере расчёта скидок в интернет-магазине.
# Код показывает, как нарушение LSP приводит к ошибкам, а соблюдение LSP делает код надёжным и гибким.

from abc import ABC, abstractmethod
from enum import Enum
from typing import List

'''
LSP - Принцип подстановки Барбары Лисков
LSP -> Liskov Substitution Principle
      Объекты дочернего класса должны быть полностью взаимозаменяемы с объектами родительского класса
      без изменения поведения программы.
Пример: Если у тебя есть класс для расчёта скидок, любой его подкласс (например, фиксированная скидка или процентная)
        должен работать так, чтобы его можно было подставить вместо родительского класса, и программа не сломалась.
Более детальное описание в конце кода.
'''

# --- Перечисления для атрибутов товара ---
class Color(Enum):
    RED = 1
    GREEN = 2
    BLUE = 3

# --- Класс товара ---
class Product:
    """
    Класс, представляющий товар в магазине.
    Его единственная ответственность — хранить данные о товаре (название, цвет, цена).
    Это соответствует SRP и помогает в контексте LSP, так как товар не зависит от логики скидок.
    """
    def __init__(self, name: str, color: Color, price: float):
        self.name = name
        self.color = color
        self.price = price

# --- Пример нарушения LSP ---
class DiscountBad(ABC):
    """
    Абстрактный класс для скидок. Определяет метод apply, который должен возвращать цену после скидки.
    """
    @abstractmethod
    def apply(self, product: Product) -> float:
        pass

class FixedDiscountBad(DiscountBad):
    """
    Фиксированная скидка: вычитает фиксированную сумму из цены.
    """
    def __init__(self, amount: float):
        self.amount = amount

    def apply(self, product: Product) -> float:
        return product.price - self.amount

class PercentageDiscountBad(DiscountBad):
    """
    Процентная скидка: уменьшает цену на заданный процент.
    Нарушение LSP: если процент больше 100, возвращается отрицательная цена, что ломает логику.
    Это нарушает контракт родительского класса, так как метод apply должен возвращать
    неотрицательную цену.
    """
    def __init__(self, percentage: float):
        self.percentage = percentage

    def apply(self, product: Product) -> float:
        # Нет проверки на отрицательную цену
        return product.price * (1 - self.percentage / 100)

class OrderProcessorBad:
    """
    Класс для обработки заказа. Ожидает, что любой объект DiscountBad вернёт корректную цену.
    Проблема: PercentageDiscountBad может вернуть отрицательную цену, что нарушает логику.
    """
    def calculate_total(self, products: List[Product], discount: DiscountBad) -> float:
        total = 0
        for product in products:
            discounted_price = discount.apply(product)
            total += discounted_price
        return total

# --- Пример соблюдения LSP ---
class Discount(ABC):
    """
    Абстрактный класс для скидок. Гарантирует, что метод apply возвращает неотрицательную цену.
    Это контракт, который должны соблюдать все подклассы.
    """
    @abstractmethod
    def apply(self, product: Product) -> float:
        pass

class FixedDiscount(Discount):
    """
    Фиксированная скидка: вычитает фиксированную сумму, но не позволяет цене стать отрицательной.
    Соблюдает LSP: можно подставить вместо Discount, и поведение останется корректным.
    """
    def __init__(self, amount: float):
        self.amount = amount

    def apply(self, product: Product) -> float:
        discounted_price = product.price - self.amount
        return max(0.0, discounted_price)

class PercentageDiscount(Discount):
    """
    Процентная скидка: уменьшает цену на заданный процент, но не позволяет цене стать отрицательной.
    Соблюдает LSP: метод apply возвращает корректную цену, как ожидает родительский класс.
    """
    def __init__(self, percentage: float):
        self.percentage = max(0.0, min(100.0, percentage))  # Ограничиваем процент от 0 до 100

    def apply(self, product: Product) -> float:
        discounted_price = product.price * (1 - self.percentage / 100)
        return max(0.0, discounted_price)

class OrderProcessor:
    """
    Класс для обработки заказа. Работает с любым объектом Discount, не беспокоясь о некорректных ценах.
    Благодаря соблюдению LSP можно подставить любой подкласс Discount, и всё будет работать.
    """
    def calculate_total(self, products: List[Product], discount: Discount) -> float:
        total = 0
        for product in products:
            discounted_price = discount.apply(product)
            total += discounted_price
        return total

# --- Демонстрация использования ---
def main():
    """
    Показывает, как работают оба подхода:
    - OrderProcessorBad: нарушает LSP, так как PercentageDiscountBad может вернуть отрицательную цену.
    - OrderProcessor: соблюдает LSP, так как все скидки возвращают корректные цены.
    """
    # Создаём тестовые товары
    products = [
        Product("T-Shirt", Color.RED, 20.0),
        Product("Table", Color.GREEN, 150.0),
    ]

    # --- Нарушение LSP ---
    print("=== Нарушение LSP (OrderProcessorBad) ===")
    bad_processor = OrderProcessorBad()
    fixed_discount_bad = FixedDiscountBad(10.0)
    percentage_discount_bad = PercentageDiscountBad(150.0)  # Некорректный процент

    print("Фиксированная скидка ($10):")
    total = bad_processor.calculate_total(products, fixed_discount_bad)
    print(f"Итоговая сумма: ${total:.2f}")

    print("\nПроцентная скидка (150%):")
    total = bad_processor.calculate_total(products, percentage_discount_bad)
    print(f"Итоговая сумма: ${total:.2f}")  # Отрицательная сумма!

    # --- Соблюдение LSP ---
    print("\n=== Соблюдение LSP (OrderProcessor) ===")
    processor = OrderProcessor()
    fixed_discount = FixedDiscount(10.0)
    percentage_discount = PercentageDiscount(150.0)  # Процент ограничен до 100

    print("Фиксированная скидка ($10):")
    total = processor.calculate_total(products, fixed_discount)
    print(f"Итоговая сумма: ${total:.2f}")

    print("\nПроцентная скидка (150% ограничена до 100%):")
    total = processor.calculate_total(products, percentage_discount)
    print(f"Итоговая сумма: ${total:.2f}")  # Корректная сумма

if __name__ == "__main__":
    main()

'''
Принцип подстановки Барбары Лисков (Liskov Substitution Principle) — гласит:
  Объекты дочернего класса должны быть полностью взаимозаменяемы с объектами родительского класса
    без изменения поведения программы. Это означает, что подклассы должны соблюдать контракт родительского класса,
    чтобы их можно было использовать в любом месте, где ожидается родительский класс.

Пример из кода:
  - В OrderProcessorBad (нарушение LSP) класс PercentageDiscountBad может вернуть отрицательную цену,
      что нарушает контракт DiscountBad, так как цена не должна быть отрицательной.
      Это приводит к ошибке: итоговая сумма заказа становится отрицательной, что ломает логику магазина.
  - В хорошем подходе (FixedDiscount, PercentageDiscount) подклассы соблюдают контракт Discount:
    * Метод apply всегда возвращает неотрицательную цену.
    * OrderProcessor работает с любым подклассом Discount без ошибок.

Почему нужно использовать LSP?
  LSP обеспечивает надёжность и предсказуемость кода. Без LSP подклассы могут вести себя неожиданно,
    ломая логику программы. Например, если подставить PercentageDiscountBad вместо DiscountBad,
    программа может вернуть отрицательную цену, что недопустимо в интернет-магазине.

Когда LSP особенно важен:
  - Работа с полиморфизмом: Если у тебя есть базовый класс (например, Discount) и несколько подклассов
      (FixedDiscount, PercentageDiscount), LSP гарантирует, что любой подкласс можно использовать
      без риска сломать программу.
  - Большие проекты: В крупных системах, где классы используются в разных частях, нарушение LSP может привести
      к трудноуловимым багам.
  - Командная разработка: Когда несколько разработчиков создают подклассы, LSP помогает обеспечить единообразное 
      поведение.
  - Тестирование: Код, следующий LSP, легче тестировать, так как подклассы ведут себя предсказуемо.

Пример из реальной жизни:
  В интернет-магазине есть система скидок. Если PercentageDiscount возвращает отрицательную цену,
    пользователь может "заработать" деньги, купив товар. Это баг, который ломает бизнес-логику.
  LSP гарантирует, что все скидки (фиксированные, процентные) ведут себя корректно, чтобы итоговая сумма
    всегда была неотрицательной.

Преимущества LSP
  - Надёжность: Подклассы не ломают программу, если их подставить вместо родительского класса.
  - Гибкость: Можно добавлять новые подклассы (например, новый тип скидки), не меняя код, который использует базовый 
      класс.
  - Лёгкость тестирования: Подклассы можно тестировать отдельно, зная, что они соблюдают контракт родителя.
  - Читаемость и модульность: Код становится предсказуемым, так как подклассы следуют единым правилам.

Пример из кода:
  Класс OrderProcessor работает с любым объектом Discount, потому что FixedDiscount и PercentageDiscount
    соблюдают контракт: метод apply возвращает неотрицательную цену.
  В плохом подходе PercentageDiscountBad нарушает контракт, возвращая отрицательную цену.

Недостатки и ограничения LSP
  - Сложность проектирования: Нужно заранее продумать контракт родительского класса (например, что apply
      должен возвращать неотрицательную цену), что требует опыта.
  - Ограничения на подклассы: Подклассы не могут делать что угодно — они должны строго следовать контракту родителя,
      что может ограничивать гибкость.
  - Дополнительный код: Чтобы избежать нарушения LSP, иногда нужно добавлять проверки (например, max(0, discounted_price)).

Когда LSP не нужен:
  - Если проект маленький и не использует полиморфизм (например, нет базового класса и подклассов).
  - Если ты пишешь прототип, где важна скорость, а не надёжность.
  - Если подклассы никогда не будут подставляться вместо родительского класса.

Как понять, что LSP нарушен?
  - Подстановка подкласса ломает программу: например, PercentageDiscountBad возвращает отрицательную цену.
  - Подкласс добавляет неожиданные побочные эффекты: например, PercentageDiscountBad меняет цену так,
      что она становится некорректной.
  - Код, использующий базовый класс, вынужден знать о конкретных подклассах и добавлять проверки 
      (например, `if isinstance(discount, PercentageDiscountBad): ...`), чтобы избежать ошибок.

Пример из кода:
  В OrderProcessorBad подстановка PercentageDiscountBad вместо DiscountBad приводит к отрицательной сумме.
  Это нарушает контракт, так как цена не должна быть отрицательной.
  В хорошем подходе FixedDiscount и PercentageDiscount всегда возвращают корректную цену.

Как применять LSP?
  - Определять чёткий "контракт": В документации или через аннотации типов укажите, что должен делать метод
      родительского класса (например, `apply` возвращает неотрицательную цену).
  - Проверять поведение подклассов: Убедись, что подклассы не нарушают контракт (например, проверка max(0, ...)).
  - Избегать условных проверок: Код, использующий базовый класс, не должен проверять тип подкласса
      (например, if isinstance(discount, PercentageDiscount)).
  - Использовать абстракции: Создавай базовые классы или интерфейсы (как Discount), чтобы подклассы
      следовали единому контракту.

Пример из кода:
  Класс Discount определяет контракт: метод apply должен возвращать неотрицательную цену.
  FixedDiscount и PercentageDiscount соблюдают этот контракт, поэтому OrderProcessor работает корректно
  с любым подклассом Discount.
'''